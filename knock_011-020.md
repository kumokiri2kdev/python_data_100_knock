# 小売店のデータでデータ加工を行う１０本ノック

## データの読み込み

'csv/uriage.csv' と 'csv/kokyaku_daicho.xlsx' を読み込め。

```python
import pandas as pd
 
uriage_data = pd.read_csv('csv/uriage.csv')
kokyaku_data = pd.read_excel('csv/kokyaku_daicho.xlsx') 
```

## データ種類の列挙
oriage_data の 'item_name' を列挙せよ。

```python
pd.unique(uriage_data.item_name)
```
## データの変換
アルファベットの小文字を大文字に変換せよ。

```python
uriage_data['item_name'] = uriage_data['item_name'].str.upper()
```

スペースを削除せよ。
```python
uriage_data['item_name'] = uriage_data['item_name'].str.replace('　','')
uriage_data['item_name'] = uriage_data['item_name'].str.replace(' ','') 
```

## データのソート
```python
uriage_data.sort_values(by=['item_name'], ascending=True, inplace=True)  
```

## 欠損値の補完
欠損値が含まれる列の有無を確認せよ。

```python
uriage_data.isnull().any(axis=0)
```

欠損値 'item_price' を 同じ 'item_id' をもつデータの 'item_price' で補完せよ。

※ 同じ 'item_id' の 'item_price' は一定の為、最大の値を使用して保管する。

```python
flg_is_null = uriage_data['item_price'].isnull()

for tag in uriage_data.loc[flg_is_null,'item_name'].unique():
    price = uriage_data.loc[(~flg_is_null) & (uriage_data['item_name'] == tag), 'item_price'].max()
    uriage_data['item_price'].loc[(flg_is_null) & (uriage_data['item_name'] == tag)] = price 

```

[ToDo] https://note.nkmk.me/python-pandas-setting-with-copy-warning/

## 表記揺れの補正
kokyaku_data の '顧客名' から、半角・全角スペースを取り除け。

```python
pd.unique(kokyaku_data['顧客名'])

kokyaku_data['顧客名'] = kokyaku_data['顧客名'].str.replace('　','')
kokyaku_data['顧客名'] = kokyaku_data['顧客名'].str.replace(' ','')

pd.unique(kokyaku_data['顧客名'])
```

## 日付表記の補正（統一）
登録日をの表記を %Y/%m/%d の datetime64 型に統一せよ。

```python
flg_is_serial = kokyaku_data['登録日'].astype('str').str.isdigit() 

fromSerial = pd.to_timedelta(kokyaku_data.loc[flg_is_serial, '登録日'].astype('float'), unit='D') + pd.to_datetime('1900/01/01')
fromString = pd.to_datetime(kokyaku_data.loc[~flg_is_serial,'登録日']) 

kokyaku_data['登録日'] = pd.concat([fromSerial, fromString]) 
```

登録日から登録月列を追加せよ。

```python
kokyaku_data['登録月'] = kokyaku_data['登録日'].dt.strftime('%Y/%m')
```

登録日から登録月列を数値で追加せよ。
```python
kokyaku_data['purchase_month'].dt.strftime('%Y%m').astype('int')
```


## グループ化
月ごとの顧客数を計算せよ。

```python
kokyaku_data.groupby(by='登録月')['顧客名'].count()
```

```
登録月
2017/01    15
2017/02    11
2017/03    14
2017/04    15
2017/05    13
2017/06    14
2017/07    17
2018/01    13
2018/02    15
2018/03    17
2018/04     5
2018/05    19
2018/06    13
2018/07    17
2019/04     2
Name: 顧客名, dtype: int64
```

売り上げ月を数値で

## データマージ
uriage_data と kokyaku_data を 顧客名（'customer_name'/'顧客名')をキーに結合せよ。

```python
join_data = pd.merge(uriage_data, kokyaku_data, left_on='customer_name', right_on='顧客名', how='left')

join_data = join_data.drop('customer_name', axis=1)

```

## データのダンプ
join_data から 'purchase_date', 'purchase_month', 'item_name', 'item_price', '顧客名', 'かな', '地域', 'メールアドレス', '登録日' を抜き出して、'out/dump_data.csv' に吐き出せ。

```python
join_data[['purchase_date', 'purchase_month', 'item_name', 'item_price', '顧客名', 'かな', '地域', 'メールアドレス', '登録日']].to_csv('out/dump_data.csv', index=False) 
```

## 集計
'purchase_month' を縦軸にし、商品毎の売り上げ個数を集計をせよ。

```python
join_data.pivot_table(index='purchase_month', columns='item_name', aggfunc='size', fill_value=0)
```

'purchase_month' を縦軸にし、商品毎の売り上げ金額を集計せよ。

```python
join_data.pivot_table(index='purchase_month', columns='item_name', aggfunc='sum', fill_value=0)
```

'purchase_month' を縦軸にし、顧客毎の売り上げ個数を集計をせよ。

```python
join_data.pivot_table(index='purchase_month', columns='顧客名', aggfunc='size', fill_value=0) 
```

'purchase_month' を縦軸にし、地域毎の売り上げ個数を集計をせよ。
```python
join_data.pivot_table(index='purchase_month', columns='地域', aggfunc='size', fill_value=0) 
```

集計期間内に購入していない顧客を特定せよ。

```python
unpurchased_data = pd.merge(uriage_data, kokyaku_data, left_on='customer_name', right_on='顧客名', how='right')
unpurchased_data[unpurchased_data['purchase_date'].isnull()][['顧客名','メールアドレス']]
```
```
       顧客名                  メールアドレス
2999  福井美希  fukui_miki1@example.com
```